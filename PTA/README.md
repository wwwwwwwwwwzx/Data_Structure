# README

这个文档用来记录写这些代码获得的启发

但是250927才创建 之前写的有一些没保存下来:(



### Tree Traversals Again

> 读取数字的时候最好还是用`scanf`，如果用字符串再取出来的话，位数容易搞错
>
> 所以如果要取数，一般不要用`fgets()`，用`scanf()`





### 前+中生成树

> 想要除最后一次，每次输出后面都带空格，有两种做法：

1. 用计数器控制空格的输出

   ```c
   int cnt = time;
   // 可以是添加数据的时候cnt++
   printf(content);
   cnt--;
   if (cnt != 0)
   {
   	// 用cnt控制空格输出
   	printf(" ");
   }
   ```

2. 先保存，最后统一输出

   ```c
   int buff[MAXSIZE];
   int len;
   for ()
   {
   	buff[i] = data[i];
   	len++;
   }
   
   // 最后统一输出
   for()
   {
   	printf("%d%c", buff[i], " \n"[i == len-1]);
   	// 输出的%c由" \n"[i == len-1]决定
   	// 当i!=len-1 返回的是字符串[0]:空格
   	// 当i==len-1 返回的是字符串[1]:换行
   }
   ```


```
发现还有一种写法，和上面一个很相似
    for (int i = 0; i < N; ++i) {
        std::cout << cbt[i] << (i == N - 1 ? "" : " ");
                               ~~~~~~~~~~~~~~~~~~~~~~~~~
    }
```





### save007

> DFS/BFS的具体实现，可以先把伪代码写出来，然后再根据实际情况换成对应的内容

> 读取一行输入：用`fgets`
>
> `fgets(char*, num, stdin);`



### six_degrees_of_separation (3h59min)

>(*p)++和\*p++不一样，++优先级比\*高

> SDOS算法思路上好像就错了。我想的是，遍历开始的人start(1-vtxnum+1)，看start与target_person(也是遍历1-vtxnum+1)有没有在六度之内
>
> 但是实际上只需要遍历六层，看看六层里面有多少人就行了。我把这个问题想的复杂了好多

> 做到一半把六度忘了。要在入队前判断有没有满六层。满六层了要用continue继续处理队列中的元素，而不是break，这样子会丢元素（队列里面的还没处理好）。



### complete_binary_search_tree

> 根本没思路啊 看了视频才知道怎么写

> 有一个重要性质：**对一棵 BST 进行中序遍历，得到的一定是一个升序序列**





### huffman_tree

> 最小堆的删除是一个很固定的模板：需要两个变量parent child。根据最大堆/最小堆找child里最大/最小的，然后实现下滤。

>在一开始把需要用到的全局变量写出来，注释写清用途

> `scanf`的读数问题：

`%d` `%f` 等等都会自动跳过**前面**的空白（空格 Tab \n \t），直接读到整数/浮点数

但是%c和getchar()见到啥读啥。所以在读数的时候经常会读入一些不想要的空白，可以这样解决：

|                                  |                                                              |
| -------------------------------- | ------------------------------------------------------------ |
| `scanf(" %c");`                  | 前面的空格可以跳过 **0 个或多个**任意空白字符（空格、Tab、换行），直接找到第一个非空白字符 |
| `scanf("\n%c");`                 | 前面的\n不表示匹配一个换行符，而是可以跳过 **0 个或多个**任意空白字符（空格、Tab、换行），和上面一样，但是容易误会成匹配\n，最好不用 |
| `getchar();`<br />`scanf("%c");` | `getchar();`一次只读 1 个字符，因此**连续多个空白必须循环调用**才能清干净。<br />清理完后下一行的`scanf("%c");`就可以正常读入了 |

在 scanf 的格式串里，**任何一个空白字符**（空格、`\t`、`\n`、`\r`、`\v`、`\f`），都**不**表示“匹配一个”，而表示 **“连续吃进 0 个或多个任意空白字符”**，直到碰到第一个非空白为止。

所以 

`scanf(" %c", &c)` 
`scanf("\n%c", &c)` 
`scanf(" \t\n \t%c", &c)`  

这三条在功能上**毫无区别**，都会把前面所有空白一次性清光，再把第一个非空白交给 `%c`。 
**唯一区别**是可读性：空格最短，最不会误导人，所以**永远优先用空格**。



这里还引出来一个问题

```c
scanf("%d\n");
scanf("%c");
```

我想输入`4\nc`，但是程序不是这样的：输入`4\n`程序就停住了因为跳过了一个空白，要等到下一个非空白，第一个`scanf`才会停止。这时我输入`c\n`，这时第一个`scanf`才结束。接下来到了第二个`scanf`处，又需要输入了。所以这种写法是不对的。





### harry_potter_s_exam (2h21min）

> 没看视频就写出来了，但是是因为算法不用自己想。谢谢Dijkstra()。

> 上一题的"在一开始把需要用到的全局变量写出来，注释写清用途"真的很有用，写一半停了，再回来也能看得懂
>
> 注释真的很重要！

> 在数组里找最大值/最小值和其下标的时候，如果还涉及到另一个限定数组的话，初始化min/max有讲究
>
> 比如这一题，要找的是**未访问过的**最小值，min就不能取`Distance[0]`，因为可能0是最小但是已访问过。所以min要用IFINITY初始化。

> 判断某个情况存不存在可以：
>
> `int V = -1` 初始化成-1
>
> 在复杂判断里面如果发现存在-> `V = value`
>
> 最后判断V是不是-1。如果是-> 不存在

> 20251020补：
>
> 好像算法用得不对。题目要求的是从任意点A到另一任意点B的最短距离，这就是Floyd算法的具体应用。虽然Dijkstra也能做得到，但是Floyd是用来做这件事的，Dijkstra主要是解决指定点A到其它任一点的最短距离。





#### saving_james_bond_hard(2 days)

> Floyd算法的实现中，中转结点k必须放在最外层循环

> Floyd算出了最短路径，但是没有记录最短路径是怎么走出来的 -> 需要一个二维数组Next记录。`Next[i][j]`表示的是从i到j，走出的第一个点的坐标。
>
> Next的初始化：
>
> 如果ij连通，则赋值为j，如果不连通，则赋值为-1
>
> 在Floyd算法里面，如果可以找到中转点k，就要把`Next[i][j]`赋值成`Next[i][k]`

> 有时涉及到多个数组的时候，要分清变量到底是哪个数组的下标

> 这题比较重要的是这个，`if (D[i][k] != INFINITY && D[k][j] != INFINITY && D[i][j] > D[i][k] + D[k][j])`
>
> 只要没判断`D[i][k]`和`D[k][j]`之中有没有INFINITY，就一定错
>
> 因为一开始我INFINITY定义成2147483647，INT_MAX。如果D[i][k]`和`D[k][j]`之中有INFINITY，相加之后一定会溢出，成一个很小很小的数，就变成死循环了。



#### saving_james_bond_hard_BFS（GEMINI）

> 这段代码是Gemini写的，可以直接AC。忽然发现Gemini的coding蛮厉害的，原先用Floyd的两个Bug都是它找出来的，上下文还挺长的。

> 这周在看Java，没时间搞DS，虽然Java进度也不快

> 如果有多个结果，选择第一步最小的那一跳输出，这里是先把第一跳能跳到的按第一跳的大小排序，然后再进行BFS。

> 这里的BFS不是之前那种典型的BFS，是多源BFS（ai说本质上仍然是BFS，一层一层向外拓展）。
>
> 先把第一跳能跳到的鳄鱼按第一跳从小到大排序，然后把这些鳄鱼入队
>
> 之后就是BFS的正常步骤，每一次入队都是按照第一跳从小到大的顺序