# README

这个文档用来记录写这些代码获得的启发

但是250927才创建 之前写的有一些没保存下来:(



### Tree Traversals Again

> 读取数字的时候最好还是用`scanf`，如果用字符串再取出来的话，位数容易搞错
>
> 所以如果要取数，一般不要用`fgets()`，用`scanf()`





### 前+中生成树

> 想要除最后一次，每次输出后面都带空格，有两种做法：

1. 用计数器控制空格的输出

   ```c
   int cnt = time;
   // 可以是添加数据的时候cnt++
   printf(content);
   cnt--;
   if (cnt != 0)
   {
   	// 用cnt控制空格输出
   	printf(" ");
   }
   ```

2. 先保存，最后统一输出

   ```c
   int buff[MAXSIZE];
   int len;
   for ()
   {
   	buff[i] = data[i];
   	len++;
   }
   
   // 最后统一输出
   for()
   {
   	printf("%d%c", buff[i], " \n"[i == len-1]);
   	// 输出的%c由" \n"[i == len-1]决定
   	// 当i!=len-1 返回的是字符串[0]:空格
   	// 当i==len-1 返回的是字符串[1]:换行
   }
   ```


```
发现还有一种写法，和上面一个很相似
    for (int i = 0; i < N; ++i) {
        std::cout << cbt[i] << (i == N - 1 ? "" : " ");
                               ~~~~~~~~~~~~~~~~~~~~~~~~~
    }
```





### save007

> DFS/BFS的具体实现，可以先把伪代码写出来，然后再根据实际情况换成对应的内容

> 读取一行输入：用`fgets`
>
> `fgets(char*, num, stdin);`



### six_degrees_of_separation (3h59min)

>(*p)++和\*p++不一样，++优先级比\*高

> SDOS算法思路上好像就错了。我想的是，遍历开始的人start(1-vtxnum+1)，看start与target_person(也是遍历1-vtxnum+1)有没有在六度之内
>
> 但是实际上只需要遍历六层，看看六层里面有多少人就行了。我把这个问题想的复杂了好多

> 做到一半把六度忘了。要在入队前判断有没有满六层。满六层了要用continue继续处理队列中的元素，而不是break，这样子会丢元素（队列里面的还没处理好）。



### complete_binary_search_tree

> 根本没思路啊 看了视频才知道怎么写

> 有一个重要性质：**对一棵 BST 进行中序遍历，得到的一定是一个升序序列**





### huffman_tree

> 最小堆的删除是一个很固定的模板：需要两个变量parent child。根据最大堆/最小堆找child里最大/最小的，然后实现下滤。

>在一开始把需要用到的全局变量写出来，注释写清用途

> `scanf`的读数问题：

`%d` `%f` 等等都会自动跳过**前面**的空白（空格 Tab \n \t），直接读到整数/浮点数

但是%c和getchar()见到啥读啥。所以在读数的时候经常会读入一些不想要的空白，可以这样解决：

|                                  |                                                              |
| -------------------------------- | ------------------------------------------------------------ |
| `scanf(" %c");`                  | 前面的空格可以跳过 **0 个或多个**任意空白字符（空格、Tab、换行），直接找到第一个非空白字符 |
| `scanf("\n%c");`                 | 前面的\n不表示匹配一个换行符，而是可以跳过 **0 个或多个**任意空白字符（空格、Tab、换行），和上面一样，但是容易误会成匹配\n，最好不用 |
| `getchar();`<br />`scanf("%c");` | `getchar();`一次只读 1 个字符，因此**连续多个空白必须循环调用**才能清干净。<br />清理完后下一行的`scanf("%c");`就可以正常读入了 |

在 scanf 的格式串里，**任何一个空白字符**（空格、`\t`、`\n`、`\r`、`\v`、`\f`），都**不**表示“匹配一个”，而表示 **“连续吃进 0 个或多个任意空白字符”**，直到碰到第一个非空白为止。

所以 

`scanf(" %c", &c)` 
`scanf("\n%c", &c)` 
`scanf(" \t\n \t%c", &c)`  

这三条在功能上**毫无区别**，都会把前面所有空白一次性清光，再把第一个非空白交给 `%c`。 
**唯一区别**是可读性：空格最短，最不会误导人，所以**永远优先用空格**。



这里还引出来一个问题

```c
scanf("%d\n");
scanf("%c");
```

我想输入`4\nc`，但是程序不是这样的：输入`4\n`程序就停住了因为跳过了一个空白，要等到下一个非空白，第一个`scanf`才会停止。这时我输入`c\n`，这时第一个`scanf`才结束。接下来到了第二个`scanf`处，又需要输入了。所以这种写法是不对的。